#!/bin/bash

################################################################################
# Pre-push hook template
#
# This hook:
# 1. Analyzes commits using semantic versioning
# 2. Prompts for breaking changes if needed
# 3. Automatically updates VERSION and CHANGELOG.md
# 4. Can be disabled via universal-ci.config.json
#
# Installation:
#   cp .github/hooks/pre-push .git/hooks/pre-push
#   chmod +x .git/hooks/pre-push
#
# Configuration (universal-ci.config.json):
#   {
#     "semver": {
#       "enabled": true,
#       "auto_update_version": true,
#       "require_breaking_change_confirmation": true
#     }
#   }
################################################################################

set -e

REPO_ROOT="$(git rev-parse --show-toplevel)"
SCRIPTS_DIR="${REPO_ROOT}/.github/scripts"
CONFIG_FILE="${REPO_ROOT}/universal-ci.config.json"
VERSION_FILE="${REPO_ROOT}/VERSION"
CHANGELOG_FILE="${REPO_ROOT}/CHANGELOG.md"
BUMP_SCRIPT="${SCRIPTS_DIR}/bump-version.sh"
SEMVER_SCRIPT="${SCRIPTS_DIR}/semantic-version.sh"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

################################################################################
# Helper Functions
################################################################################

log_info() {
  echo -e "${BLUE}‚Ñπ ${1}${NC}" >&2
}

log_success() {
  echo -e "${GREEN}‚úì ${1}${NC}" >&2
}

log_warn() {
  echo -e "${YELLOW}‚ö† ${1}${NC}" >&2
}

log_error() {
  echo -e "${RED}‚úó ${1}${NC}" >&2
}

# Read config value from universal-ci.config.json
read_config_bool() {
  local key="$1"
  local default="${2:-true}"
  
  if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "$default"
    return
  fi
  
  local value=$(sed -n "s/.*\"$key\"[[:space:]]*:[[:space:]]*\(true\|false\).*/\1/p" "$CONFIG_FILE" 2>/dev/null | head -1)
  [[ -z "$value" ]] && value="$default"
  echo "$value"
}

# Check if there are commits since last tag
has_commits_to_release() {
  local last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
  
  if [[ -z "$last_tag" ]]; then
    # No tags yet, check if there are any commits
    [[ -n "$(git rev-list HEAD 2>/dev/null)" ]]
  else
    # Check if there are commits since last tag
    [[ -n "$(git log "${last_tag}..HEAD" 2>/dev/null)" ]]
  fi
}

# Read all refs from stdin to pass to auto-push if needed
# Format: <local_ref> <local_oid> <remote_ref> <remote_oid>
declare -a PUSH_REFS
while read -r line; do
  PUSH_REFS+=("$line")
done

# Check if there are commits to release
if ! has_commits_to_release; then
  log_info "No commits to release, skipping semantic versioning"
  # Continue to verification
else
  # Semantic Versioning Logic
  # -------------------------
  
  # Check if semantic versioning is enabled
  SEMVER_ENABLED=$(read_config_bool "semver.enabled" "true")
  
  if [[ "$SEMVER_ENABLED" == "true" && -f "$SEMVER_SCRIPT" ]]; then
    log_info "Analyzing commits for semantic versioning..."
    
    # Analyze commits
    if ! ANALYSIS=$("$SEMVER_SCRIPT" --analyze 2>/dev/null); then
      log_error "Failed to analyze commits"
      exit 1
    fi
    
    # Parse JSON response
    BUMP_TYPE=$(echo "$ANALYSIS" | sed -n 's/.*"bump_type"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
    BREAKING_COUNT=$(echo "$ANALYSIS" | sed -n 's/.*"breaking"[[:space:]]*:[[:space:]]*\([0-9]*\).*/\1/p')
    FEATURE_COUNT=$(echo "$ANALYSIS" | sed -n 's/.*"features"[[:space:]]*:[[:space:]]*\([0-9]*\).*/\1/p')
    
    log_info "Found: $FEATURE_COUNT features, $BREAKING_COUNT breaking changes"
    log_success "Suggested version bump: ${YELLOW}${BUMP_TYPE}${NC}"
    
    # Breaking change confirmation
    REQUIRE_BREAKING_CONFIRM=$(read_config_bool "semver.require_breaking_change_confirmation" "true")
    if [[ $BREAKING_COUNT -gt 0 && "$REQUIRE_BREAKING_CONFIRM" == "true" ]]; then
      log_warn "Breaking changes detected!"
      echo ""
      while true; do
        read -p "$(echo -e ${BLUE}Confirm breaking changes? [yes/no]${NC}: )" confirm < /dev/tty
        confirm=$(echo "$confirm" | tr '[:upper:]' '[:lower:]')
        if [[ "$confirm" == "yes" ]]; then break;
        elif [[ "$confirm" == "no" ]]; then log_error "Push cancelled"; exit 1;
        fi
      done
    fi
    
    # Store bump info for later (after verification)
    SHOULD_BUMP=true
  fi
fi

# -------------------------
# 1. Run Verification First
# -------------------------
# We verify BEFORE bumping to ensure we don't tag broken code

echo "üîç Running Universal CI verification..."

if [ -f "${REPO_ROOT}/run-ci.sh" ]; then
    "${REPO_ROOT}/run-ci.sh"
elif command -v curl >/dev/null 2>&1; then
    curl -sL https://raw.githubusercontent.com/orchestrate-solutions/universal-ci/main/run-ci.sh | sh
else
    echo "‚ö†Ô∏è  run-ci.sh not found and curl not available"
    exit 0
fi

exit_code=$?

if [ $exit_code -ne 0 ]; then
    echo ""
    echo "‚ùå Verification failed. Push blocked."
    echo "   Fix the issues above and try again."
    exit 1
fi

echo "‚úÖ Verification passed."

# -------------------------
# 2. Bump & Auto-Push
# -------------------------

if [[ "$SHOULD_BUMP" == "true" ]]; then
  AUTO_UPDATE=$(read_config_bool "semver.auto_update_version" "true")
  
  if [[ "$AUTO_UPDATE" == "true" && -f "$VERSION_FILE" && -f "$BUMP_SCRIPT" ]]; then
  
    # Check if last commit was already a release (avoid loop)
    last_msg=$(git log -1 --pretty=%B)
    if [[ "$last_msg" == chore:\ release\ v* ]]; then
      log_info "Version bump already committed. Proceeding with push..."
      exit 0
    fi
    
    log_info "Auto-updating VERSION to $BUMP_TYPE bump..."
    
    # Run bump
    BUMP_OUTPUT=$("$BUMP_SCRIPT" "$BUMP_TYPE")
    if [[ $? -eq 0 ]]; then
      NEW_VERSION=$(head -n 1 "$VERSION_FILE")
      log_success "Updated VERSION to v${NEW_VERSION}"
      
      # Commit
      git add "$VERSION_FILE" "$CHANGELOG_FILE" package.json 2>/dev/null || true
      git commit -m "chore: release v${NEW_VERSION} [skip ci]" --no-verify >/dev/null 2>&1
      
      log_success "Committed release v${NEW_VERSION}"
      
      # Auto-Push
      # We construct the push command based on what the user originally requested
      # $1 is remote name, $2 is remote URL
      REMOTE_NAME="$1"
      
      if [[ -z "$REMOTE_NAME" ]]; then REMOTE_NAME="origin"; fi
      
      echo "üöÄ Auto-pushing to $REMOTE_NAME..."
      
      # Push each ref requested
      for ref_line in "${PUSH_REFS[@]}"; do
         # line is: local_ref local_sha remote_ref remote_sha
         # We want to push HEAD to remote_ref
         parts=($ref_line)
         remote_ref="${parts[2]}"
         
         if [[ -n "$remote_ref" ]]; then
           log_info "Pushing HEAD -> $remote_ref"
           git push --no-verify "$REMOTE_NAME" "HEAD:$remote_ref"
         fi
      done
      
      echo ""
      log_warn "---------------------------------------------------------------"
      log_warn "‚úÖ AUTOMATION COMPLETE: Version bumped & pushed."
      log_warn "‚ÑπÔ∏è  The original push command will now 'fail' because it was"
      log_warn "   superseded by the auto-push. This is normal."
      log_warn "---------------------------------------------------------------"
      
      exit 1 # Block original push (it's stale now)
    else
      log_error "Failed to update version block"
      exit 1
    fi
  fi
fi

exit 0
